 java_cup.runtime.*;

import EDU.Washington.grad.gjb.cassowary.*;

parser code
{:
	public static void main(String args[]) throws Exception
	{
		new parser(new Yylex(System.in)).parse();
	}
:}

terminal GEQ, LEQ, EQ, PLUS, MINUS, UMINUS, TIMES, DIVIDE, LPAREN, RPAREN;
terminal Double NUMBER;
terminal String VARIABLE;

non terminal constraint, equation, inequality, expr;

precedence left TIMES, DIVIDE;
precedence left PLUS, MINUS;
precedence left UMINUS;

constraint	::=	  equation:a			{: RESULT = a;													:}
			| inequality:a			{: RESULT = a;													:};

equation	::=	  expr:a EQ expr:b		{: RESULT = (Object)(new ClLinearEquation	((ClLinearExpression) a, (ClLinearExpression) b));		:};

inequality	::=	  expr:a GEQ expr:b		{: RESULT = (Object)(new ClLinearInequality	((ClLinearExpression) a, CL.GEQ, (ClLinearExpression) b)); 	:}
			| expr:a LEQ expr:b		{: RESULT = (Object)(new ClLinearInequality	((ClLinearExpression) a, CL.LEQ, (ClLinearExpression) b)); 	:};

expr		::=	  NUMBER:a			{: RESULT = (Object)(a);											:}
			| VARIABLE:a			{: RESULT = (Object)(new ClVariable(a));									:}
			| expr:a PLUS expr:b		{: RESULT = (Object)(CL.Plus	((ClLinearExpression) a	, (ClLinearExpression) b));				:}
			| expr:a MINUS expr:b		{: RESULT = (Object)(CL.Minus	((ClLinearExpression) a	, (ClLinearExpression) b));				:}
			| expr:a TIMES expr:b		{: RESULT = (Object)(CL.Times	((ClLinearExpression) a	, (ClLinearExpression) b));				:}
			| expr:a DIVIDE expr:b		{: RESULT = (Object)(CL.Divide	((ClLinearExpression) a	, (ClLinearExpression) b));				:}
			| MINUS expr:a			{: RESULT = (Object)(CL.Times	(-1			, (ClLinearExpression) a));				:}
			%prec UMINUS
			| LPAREN expr:a RPAREN		{: RESULT = a;													:};
